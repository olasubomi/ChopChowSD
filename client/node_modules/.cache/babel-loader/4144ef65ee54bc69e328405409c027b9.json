{"ast":null,"code":"import { NO_RETRY_INCREMENT, RETRY_COST, TIMEOUT_RETRY_COST } from \"./constants\";\nexport var getDefaultRetryQuota = function getDefaultRetryQuota(initialRetryTokens, options) {\n  var _a, _b, _c;\n\n  var MAX_CAPACITY = initialRetryTokens;\n  var noRetryIncrement = (_a = options === null || options === void 0 ? void 0 : options.noRetryIncrement) !== null && _a !== void 0 ? _a : NO_RETRY_INCREMENT;\n  var retryCost = (_b = options === null || options === void 0 ? void 0 : options.retryCost) !== null && _b !== void 0 ? _b : RETRY_COST;\n  var timeoutRetryCost = (_c = options === null || options === void 0 ? void 0 : options.timeoutRetryCost) !== null && _c !== void 0 ? _c : TIMEOUT_RETRY_COST;\n  var availableCapacity = initialRetryTokens;\n\n  var getCapacityAmount = function getCapacityAmount(error) {\n    return error.name === \"TimeoutError\" ? timeoutRetryCost : retryCost;\n  };\n\n  var hasRetryTokens = function hasRetryTokens(error) {\n    return getCapacityAmount(error) <= availableCapacity;\n  };\n\n  var retrieveRetryTokens = function retrieveRetryTokens(error) {\n    if (!hasRetryTokens(error)) {\n      throw new Error(\"No retry token available\");\n    }\n\n    var capacityAmount = getCapacityAmount(error);\n    availableCapacity -= capacityAmount;\n    return capacityAmount;\n  };\n\n  var releaseRetryTokens = function releaseRetryTokens(capacityReleaseAmount) {\n    availableCapacity += capacityReleaseAmount !== null && capacityReleaseAmount !== void 0 ? capacityReleaseAmount : noRetryIncrement;\n    availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n  };\n\n  return Object.freeze({\n    hasRetryTokens: hasRetryTokens,\n    retrieveRetryTokens: retrieveRetryTokens,\n    releaseRetryTokens: releaseRetryTokens\n  });\n};","map":{"version":3,"sources":["/home/chuka/joe/ChopChowSD/node_modules/@aws-sdk/middleware-retry/dist-es/defaultRetryQuota.js"],"names":["NO_RETRY_INCREMENT","RETRY_COST","TIMEOUT_RETRY_COST","getDefaultRetryQuota","initialRetryTokens","options","_a","_b","_c","MAX_CAPACITY","noRetryIncrement","retryCost","timeoutRetryCost","availableCapacity","getCapacityAmount","error","name","hasRetryTokens","retrieveRetryTokens","Error","capacityAmount","releaseRetryTokens","capacityReleaseAmount","Math","min","Object","freeze"],"mappings":"AAAA,SAASA,kBAAT,EAA6BC,UAA7B,EAAyCC,kBAAzC,QAAmE,aAAnE;AACA,OAAO,IAAIC,oBAAoB,GAAG,SAAvBA,oBAAuB,CAAUC,kBAAV,EAA8BC,OAA9B,EAAuC;AACrE,MAAIC,EAAJ,EAAQC,EAAR,EAAYC,EAAZ;;AACA,MAAIC,YAAY,GAAGL,kBAAnB;AACA,MAAIM,gBAAgB,GAAG,CAACJ,EAAE,GAAGD,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACK,gBAAhE,MAAsF,IAAtF,IAA8FJ,EAAE,KAAK,KAAK,CAA1G,GAA8GA,EAA9G,GAAmHN,kBAA1I;AACA,MAAIW,SAAS,GAAG,CAACJ,EAAE,GAAGF,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACM,SAAhE,MAA+E,IAA/E,IAAuFJ,EAAE,KAAK,KAAK,CAAnG,GAAuGA,EAAvG,GAA4GN,UAA5H;AACA,MAAIW,gBAAgB,GAAG,CAACJ,EAAE,GAAGH,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACO,gBAAhE,MAAsF,IAAtF,IAA8FJ,EAAE,KAAK,KAAK,CAA1G,GAA8GA,EAA9G,GAAmHN,kBAA1I;AACA,MAAIW,iBAAiB,GAAGT,kBAAxB;;AACA,MAAIU,iBAAiB,GAAG,SAApBA,iBAAoB,CAAUC,KAAV,EAAiB;AAAE,WAAQA,KAAK,CAACC,IAAN,KAAe,cAAf,GAAgCJ,gBAAhC,GAAmDD,SAA3D;AAAwE,GAAnH;;AACA,MAAIM,cAAc,GAAG,SAAjBA,cAAiB,CAAUF,KAAV,EAAiB;AAAE,WAAOD,iBAAiB,CAACC,KAAD,CAAjB,IAA4BF,iBAAnC;AAAuD,GAA/F;;AACA,MAAIK,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAUH,KAAV,EAAiB;AACvC,QAAI,CAACE,cAAc,CAACF,KAAD,CAAnB,EAA4B;AACxB,YAAM,IAAII,KAAJ,CAAU,0BAAV,CAAN;AACH;;AACD,QAAIC,cAAc,GAAGN,iBAAiB,CAACC,KAAD,CAAtC;AACAF,IAAAA,iBAAiB,IAAIO,cAArB;AACA,WAAOA,cAAP;AACH,GAPD;;AAQA,MAAIC,kBAAkB,GAAG,SAArBA,kBAAqB,CAAUC,qBAAV,EAAiC;AACtDT,IAAAA,iBAAiB,IAAIS,qBAAqB,KAAK,IAA1B,IAAkCA,qBAAqB,KAAK,KAAK,CAAjE,GAAqEA,qBAArE,GAA6FZ,gBAAlH;AACAG,IAAAA,iBAAiB,GAAGU,IAAI,CAACC,GAAL,CAASX,iBAAT,EAA4BJ,YAA5B,CAApB;AACH,GAHD;;AAIA,SAAOgB,MAAM,CAACC,MAAP,CAAc;AACjBT,IAAAA,cAAc,EAAEA,cADC;AAEjBC,IAAAA,mBAAmB,EAAEA,mBAFJ;AAGjBG,IAAAA,kBAAkB,EAAEA;AAHH,GAAd,CAAP;AAKH,CA1BM","sourcesContent":["import { NO_RETRY_INCREMENT, RETRY_COST, TIMEOUT_RETRY_COST } from \"./constants\";\nexport var getDefaultRetryQuota = function (initialRetryTokens, options) {\n    var _a, _b, _c;\n    var MAX_CAPACITY = initialRetryTokens;\n    var noRetryIncrement = (_a = options === null || options === void 0 ? void 0 : options.noRetryIncrement) !== null && _a !== void 0 ? _a : NO_RETRY_INCREMENT;\n    var retryCost = (_b = options === null || options === void 0 ? void 0 : options.retryCost) !== null && _b !== void 0 ? _b : RETRY_COST;\n    var timeoutRetryCost = (_c = options === null || options === void 0 ? void 0 : options.timeoutRetryCost) !== null && _c !== void 0 ? _c : TIMEOUT_RETRY_COST;\n    var availableCapacity = initialRetryTokens;\n    var getCapacityAmount = function (error) { return (error.name === \"TimeoutError\" ? timeoutRetryCost : retryCost); };\n    var hasRetryTokens = function (error) { return getCapacityAmount(error) <= availableCapacity; };\n    var retrieveRetryTokens = function (error) {\n        if (!hasRetryTokens(error)) {\n            throw new Error(\"No retry token available\");\n        }\n        var capacityAmount = getCapacityAmount(error);\n        availableCapacity -= capacityAmount;\n        return capacityAmount;\n    };\n    var releaseRetryTokens = function (capacityReleaseAmount) {\n        availableCapacity += capacityReleaseAmount !== null && capacityReleaseAmount !== void 0 ? capacityReleaseAmount : noRetryIncrement;\n        availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n    };\n    return Object.freeze({\n        hasRetryTokens: hasRetryTokens,\n        retrieveRetryTokens: retrieveRetryTokens,\n        releaseRetryTokens: releaseRetryTokens,\n    });\n};\n"]},"metadata":{},"sourceType":"module"}