{"ast":null,"code":"var alphabetByEncoding = {};\nvar alphabetByValue = new Array(64);\n\nfor (var i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++) {\n  var char = String.fromCharCode(i + start);\n  alphabetByEncoding[char] = i;\n  alphabetByValue[i] = char;\n}\n\nfor (var i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++) {\n  var char = String.fromCharCode(i + start);\n  var index = i + 26;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\n\nfor (var i = 0; i < 10; i++) {\n  alphabetByEncoding[i.toString(10)] = i + 52;\n  var char = i.toString(10);\n  var index = i + 52;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\n\nalphabetByEncoding[\"+\"] = 62;\nalphabetByValue[62] = \"+\";\nalphabetByEncoding[\"/\"] = 63;\nalphabetByValue[63] = \"/\";\nvar bitsPerLetter = 6;\nvar bitsPerByte = 8;\nvar maxLetterValue = 63;\nexport function fromBase64(input) {\n  var totalByteLength = input.length / 4 * 3;\n\n  if (input.slice(-2) === \"==\") {\n    totalByteLength -= 2;\n  } else if (input.slice(-1) === \"=\") {\n    totalByteLength--;\n  }\n\n  var out = new ArrayBuffer(totalByteLength);\n  var dataView = new DataView(out);\n\n  for (var i = 0; i < input.length; i += 4) {\n    var bits = 0;\n    var bitLength = 0;\n\n    for (var j = i, limit = i + 3; j <= limit; j++) {\n      if (input[j] !== \"=\") {\n        if (!(input[j] in alphabetByEncoding)) {\n          throw new TypeError(\"Invalid character \".concat(input[j], \" in base64 string.\"));\n        }\n\n        bits |= alphabetByEncoding[input[j]] << (limit - j) * bitsPerLetter;\n        bitLength += bitsPerLetter;\n      } else {\n        bits >>= bitsPerLetter;\n      }\n    }\n\n    var chunkOffset = i / 4 * 3;\n    bits >>= bitLength % bitsPerByte;\n    var byteLength = Math.floor(bitLength / bitsPerByte);\n\n    for (var k = 0; k < byteLength; k++) {\n      var offset = (byteLength - k - 1) * bitsPerByte;\n      dataView.setUint8(chunkOffset + k, (bits & 255 << offset) >> offset);\n    }\n  }\n\n  return new Uint8Array(out);\n}\nexport function toBase64(input) {\n  var str = \"\";\n\n  for (var i = 0; i < input.length; i += 3) {\n    var bits = 0;\n    var bitLength = 0;\n\n    for (var j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {\n      bits |= input[j] << (limit - j - 1) * bitsPerByte;\n      bitLength += bitsPerByte;\n    }\n\n    var bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n    bits <<= bitClusterCount * bitsPerLetter - bitLength;\n\n    for (var k = 1; k <= bitClusterCount; k++) {\n      var offset = (bitClusterCount - k) * bitsPerLetter;\n      str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];\n    }\n\n    str += \"==\".slice(0, 4 - bitClusterCount);\n  }\n\n  return str;\n}","map":{"version":3,"sources":["/home/chuka/joe/ChopChowSD/node_modules/@aws-sdk/util-base64-browser/dist-es/index.js"],"names":["alphabetByEncoding","alphabetByValue","Array","i","start","charCodeAt","limit","char","String","fromCharCode","index","toString","bitsPerLetter","bitsPerByte","maxLetterValue","fromBase64","input","totalByteLength","length","slice","out","ArrayBuffer","dataView","DataView","bits","bitLength","j","TypeError","concat","chunkOffset","byteLength","Math","floor","k","offset","setUint8","Uint8Array","toBase64","str","min","bitClusterCount","ceil"],"mappings":"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","sourcesContent":["var alphabetByEncoding = {};\nvar alphabetByValue = new Array(64);\nfor (var i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++) {\n    var char = String.fromCharCode(i + start);\n    alphabetByEncoding[char] = i;\n    alphabetByValue[i] = char;\n}\nfor (var i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++) {\n    var char = String.fromCharCode(i + start);\n    var index = i + 26;\n    alphabetByEncoding[char] = index;\n    alphabetByValue[index] = char;\n}\nfor (var i = 0; i < 10; i++) {\n    alphabetByEncoding[i.toString(10)] = i + 52;\n    var char = i.toString(10);\n    var index = i + 52;\n    alphabetByEncoding[char] = index;\n    alphabetByValue[index] = char;\n}\nalphabetByEncoding[\"+\"] = 62;\nalphabetByValue[62] = \"+\";\nalphabetByEncoding[\"/\"] = 63;\nalphabetByValue[63] = \"/\";\nvar bitsPerLetter = 6;\nvar bitsPerByte = 8;\nvar maxLetterValue = 63;\nexport function fromBase64(input) {\n    var totalByteLength = (input.length / 4) * 3;\n    if (input.slice(-2) === \"==\") {\n        totalByteLength -= 2;\n    }\n    else if (input.slice(-1) === \"=\") {\n        totalByteLength--;\n    }\n    var out = new ArrayBuffer(totalByteLength);\n    var dataView = new DataView(out);\n    for (var i = 0; i < input.length; i += 4) {\n        var bits = 0;\n        var bitLength = 0;\n        for (var j = i, limit = i + 3; j <= limit; j++) {\n            if (input[j] !== \"=\") {\n                if (!(input[j] in alphabetByEncoding)) {\n                    throw new TypeError(\"Invalid character \".concat(input[j], \" in base64 string.\"));\n                }\n                bits |= alphabetByEncoding[input[j]] << ((limit - j) * bitsPerLetter);\n                bitLength += bitsPerLetter;\n            }\n            else {\n                bits >>= bitsPerLetter;\n            }\n        }\n        var chunkOffset = (i / 4) * 3;\n        bits >>= bitLength % bitsPerByte;\n        var byteLength = Math.floor(bitLength / bitsPerByte);\n        for (var k = 0; k < byteLength; k++) {\n            var offset = (byteLength - k - 1) * bitsPerByte;\n            dataView.setUint8(chunkOffset + k, (bits & (255 << offset)) >> offset);\n        }\n    }\n    return new Uint8Array(out);\n}\nexport function toBase64(input) {\n    var str = \"\";\n    for (var i = 0; i < input.length; i += 3) {\n        var bits = 0;\n        var bitLength = 0;\n        for (var j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {\n            bits |= input[j] << ((limit - j - 1) * bitsPerByte);\n            bitLength += bitsPerByte;\n        }\n        var bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n        bits <<= bitClusterCount * bitsPerLetter - bitLength;\n        for (var k = 1; k <= bitClusterCount; k++) {\n            var offset = (bitClusterCount - k) * bitsPerLetter;\n            str += alphabetByValue[(bits & (maxLetterValue << offset)) >> offset];\n        }\n        str += \"==\".slice(0, 4 - bitClusterCount);\n    }\n    return str;\n}\n"]},"metadata":{},"sourceType":"module"}