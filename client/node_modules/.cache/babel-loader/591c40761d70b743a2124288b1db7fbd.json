{"ast":null,"code":"import { toHex } from \"@aws-sdk/util-hex-encoding\";\n\nvar Int64 = function () {\n  function Int64(bytes) {\n    this.bytes = bytes;\n\n    if (bytes.byteLength !== 8) {\n      throw new Error(\"Int64 buffers must be exactly 8 bytes\");\n    }\n  }\n\n  Int64.fromNumber = function (number) {\n    if (number > 9223372036854775807 || number < -9223372036854775808) {\n      throw new Error(\"\".concat(number, \" is too large (or, if negative, too small) to represent as an Int64\"));\n    }\n\n    var bytes = new Uint8Array(8);\n\n    for (var i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {\n      bytes[i] = remaining;\n    }\n\n    if (number < 0) {\n      negate(bytes);\n    }\n\n    return new Int64(bytes);\n  };\n\n  Int64.prototype.valueOf = function () {\n    var bytes = this.bytes.slice(0);\n    var negative = bytes[0] & 128;\n\n    if (negative) {\n      negate(bytes);\n    }\n\n    return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);\n  };\n\n  Int64.prototype.toString = function () {\n    return String(this.valueOf());\n  };\n\n  return Int64;\n}();\n\nexport { Int64 };\n\nfunction negate(bytes) {\n  for (var i = 0; i < 8; i++) {\n    bytes[i] ^= 0xff;\n  }\n\n  for (var i = 7; i > -1; i--) {\n    bytes[i]++;\n    if (bytes[i] !== 0) break;\n  }\n}","map":{"version":3,"sources":["/home/chuka/joe/ChopChowSD/node_modules/@aws-sdk/eventstream-marshaller/dist-es/Int64.js"],"names":["toHex","Int64","bytes","byteLength","Error","fromNumber","number","concat","Uint8Array","i","remaining","Math","abs","round","negate","prototype","valueOf","slice","negative","parseInt","toString","String"],"mappings":"AAAA,SAASA,KAAT,QAAsB,4BAAtB;;AACA,IAAIC,KAAK,GAAI,YAAY;AACrB,WAASA,KAAT,CAAeC,KAAf,EAAsB;AAClB,SAAKA,KAAL,GAAaA,KAAb;;AACA,QAAIA,KAAK,CAACC,UAAN,KAAqB,CAAzB,EAA4B;AACxB,YAAM,IAAIC,KAAJ,CAAU,uCAAV,CAAN;AACH;AACJ;;AACDH,EAAAA,KAAK,CAACI,UAAN,GAAmB,UAAUC,MAAV,EAAkB;AACjC,QAAIA,MAAM,GAAG,mBAAT,IAAgCA,MAAM,GAAG,CAAC,mBAA9C,EAAmE;AAC/D,YAAM,IAAIF,KAAJ,CAAU,GAAGG,MAAH,CAAUD,MAAV,EAAkB,qEAAlB,CAAV,CAAN;AACH;;AACD,QAAIJ,KAAK,GAAG,IAAIM,UAAJ,CAAe,CAAf,CAAZ;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,SAAS,GAAGC,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,KAAL,CAAWP,MAAX,CAAT,CAA5B,EAA0DG,CAAC,GAAG,CAAC,CAAL,IAAUC,SAAS,GAAG,CAAhF,EAAmFD,CAAC,IAAIC,SAAS,IAAI,GAArG,EAA0G;AACtGR,MAAAA,KAAK,CAACO,CAAD,CAAL,GAAWC,SAAX;AACH;;AACD,QAAIJ,MAAM,GAAG,CAAb,EAAgB;AACZQ,MAAAA,MAAM,CAACZ,KAAD,CAAN;AACH;;AACD,WAAO,IAAID,KAAJ,CAAUC,KAAV,CAAP;AACH,GAZD;;AAaAD,EAAAA,KAAK,CAACc,SAAN,CAAgBC,OAAhB,GAA0B,YAAY;AAClC,QAAId,KAAK,GAAG,KAAKA,KAAL,CAAWe,KAAX,CAAiB,CAAjB,CAAZ;AACA,QAAIC,QAAQ,GAAGhB,KAAK,CAAC,CAAD,CAAL,GAAW,GAA1B;;AACA,QAAIgB,QAAJ,EAAc;AACVJ,MAAAA,MAAM,CAACZ,KAAD,CAAN;AACH;;AACD,WAAOiB,QAAQ,CAACnB,KAAK,CAACE,KAAD,CAAN,EAAe,EAAf,CAAR,IAA8BgB,QAAQ,GAAG,CAAC,CAAJ,GAAQ,CAA9C,CAAP;AACH,GAPD;;AAQAjB,EAAAA,KAAK,CAACc,SAAN,CAAgBK,QAAhB,GAA2B,YAAY;AACnC,WAAOC,MAAM,CAAC,KAAKL,OAAL,EAAD,CAAb;AACH,GAFD;;AAGA,SAAOf,KAAP;AACH,CAhCY,EAAb;;AAiCA,SAASA,KAAT;;AACA,SAASa,MAAT,CAAgBZ,KAAhB,EAAuB;AACnB,OAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AACxBP,IAAAA,KAAK,CAACO,CAAD,CAAL,IAAY,IAAZ;AACH;;AACD,OAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAAC,CAArB,EAAwBA,CAAC,EAAzB,EAA6B;AACzBP,IAAAA,KAAK,CAACO,CAAD,CAAL;AACA,QAAIP,KAAK,CAACO,CAAD,CAAL,KAAa,CAAjB,EACI;AACP;AACJ","sourcesContent":["import { toHex } from \"@aws-sdk/util-hex-encoding\";\nvar Int64 = (function () {\n    function Int64(bytes) {\n        this.bytes = bytes;\n        if (bytes.byteLength !== 8) {\n            throw new Error(\"Int64 buffers must be exactly 8 bytes\");\n        }\n    }\n    Int64.fromNumber = function (number) {\n        if (number > 9223372036854775807 || number < -9223372036854775808) {\n            throw new Error(\"\".concat(number, \" is too large (or, if negative, too small) to represent as an Int64\"));\n        }\n        var bytes = new Uint8Array(8);\n        for (var i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {\n            bytes[i] = remaining;\n        }\n        if (number < 0) {\n            negate(bytes);\n        }\n        return new Int64(bytes);\n    };\n    Int64.prototype.valueOf = function () {\n        var bytes = this.bytes.slice(0);\n        var negative = bytes[0] & 128;\n        if (negative) {\n            negate(bytes);\n        }\n        return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);\n    };\n    Int64.prototype.toString = function () {\n        return String(this.valueOf());\n    };\n    return Int64;\n}());\nexport { Int64 };\nfunction negate(bytes) {\n    for (var i = 0; i < 8; i++) {\n        bytes[i] ^= 0xff;\n    }\n    for (var i = 7; i > -1; i--) {\n        bytes[i]++;\n        if (bytes[i] !== 0)\n            break;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}